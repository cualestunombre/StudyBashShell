def) 프로세스 : 실행중인 프로그램으로 독립된 메모리를 가진 작업단위 vs def)프로그램 : 코드와 저장된 데이터의 집합

1. 간단한 프로세스 명령어
ps -fe --froest를 치면 현재 실행중인 프로세스의 목록을 볼 수 있다(--forest로 인해 계층적 관계도 볼 수 있다)
echo "$?"를 치면 직전 명령어의 종료 상태를 출력할 수 있다
kill -9 [pid] 프로세스를 종료할 수 있다

2. 프로세스의 상태는 wating, running, blocked, swapped out wating, swapped out blocked 상태가 있다
참고로 I/O 작업으로 인해 긴 지연이 발생하면 운영체제는 해당 스레드를 블락시키고, 다른 스레드를 실행시킬 수 있다

init프로세스는 처음 실행되는 프로세스로 모든 프로세스의 공통 조상이다
프로세스의 종료 처리는 어떻게 이뤄지는가? 
부모 프로세스가 자식프로세스를 죽기 기다리거나, os가 죽었다고 통보해주면 뒷처리 한다

고아 프로세스 : 부모가 먼저 종료 됨 <- init이 입양해서 관리함
좀비 프로세스 : 부모가 자식을 제대로 종료처리하지 않음(자원이 완벽하게 정리되지 않아 자원 낭비가 발생할 수 있음)

프로세스 종료 상태란?
프로세스가 종료될 때 넘겨주는 정보
부모 프로세스에게 정보를 넘기게 됨

TOMCAT WAS의 예를 들어보자
WAS는 요청이 올 때마다, TomCat은 새로운 스레드를 생성한다
요청이 완료되면, 순서대로 스레드의 종료처리를 한다

파일디스크립터란?? 
파일 디스크립터(file descriptor)는 파일이나 소켓 등의 I/O 자원을 참조하기 위한 정수값으로, 해당 자원을 식별하는 역할을 합니다. 파일 디스크립터는 파일 또는 소켓과 같은 I/O 자원에 접근하려는 프로세스에게 할당되며, 리눅스에서는 파일 디스크립터를 이용하여 파일의 읽기/쓰기, 소켓 통신 등의 작업을 수행합니다.
일반적으로 0, 1, 2번 파일 디스크립터는 각각 stdin(표준 입력), stdout(표준 출력), stderr(표준 에러 출력)를 가리킵니다. 파일 디스크립터는 open() 시스템 콜을 통해 생성되며, close() 시스템 콜을 통해 소멸됩니다. 파일 디스크립터는 프로세스 별로 할당되며, fork() 시스템 콜을 이용하여 자식 프로세스를 생성하면 부모 프로세스와 파일 디스크립터를 공유합니다. 프로세스는 파일을 다룰 때 해당 파일의 파일 디스크립터를 사용하며, 파일 디스크립터는 프로세스마다 고유한 값으로 할당됩니다. 예를 들어, 프로세스 A와 B가 모두 "file.txt" 파일을 열면, A와 B는 각자의 파일 디스크립터를 가지게 됩니다. 따라서, A와 B가 "file.txt" 파일을 동시에 읽고 쓸 때 서로 영향을 미치지 않습니다. 파일 디스크립터는 파일이 아닌 다른 I/O 자원(예: 소켓)에도 사용될 수 있으며, 이러한 I/O 자원도 프로세스마다 각각의 파일 디스크립터를 사용합니다


포어그라운드 프로세스란? 
쉘의 표준 입력이 연결된 프로세스
표준 출력과 표준 에러도 쉘과 연결 됨 

백그라운드 프로세스
쉘의 표준 입력이 연결되지 않은 프로세스
표준 출력과 표준 에러는 쉘과 연결되어 있음

데몬 프로세스는 백그라운드 프로세스로만 동작하기 위해 만들어진 프로세스
표준 스트림을 갖고 시작하지만 모두 닫아 버림, 부모 프로세스를 init프로세스로 변경

시그널: 비동기 이벤트를 처리하기 위한 프로세스간 통산
주로 부모 자식간의 통신 규약